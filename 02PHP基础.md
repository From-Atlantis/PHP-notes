# 一、PHP语法规则



> 目标：PHP语法规则是为掌握PHP开发的基础规范，为后续学习和开发做准备

* PHP标记：PHP代码起始标记
* PHP注释：描述代码逻辑
* PHP语句结束符：一行代码的结束标记



## 1、PHP标记



提问：PHP可以嵌入到HTML中，那么PHP引擎如何准备识别PHP代码并进行解析呢？

答案：PHP标记



> 目标：掌握PHP的标记应用



> 概念

**PHP标记**：标记是用来帮助PHP引擎识别PHP代码的，PHP标记分为两个部分

* 标记开始：`<?php`

* 标记结束：`?>`



> 步骤

1、在开始编写PHP代码之前先使用开始标记：`<?php`

2、开始标记之后的所有内容都属于PHP引擎解析的范畴

3、在PHP代码写完之后使用结束标记：`?>`

4、如果PHP代码是一个独立的PHP文件（或者一直到最后都是PHP代码），那么可以没有结束标记`?>`



> 示例

1、有结束标记的使用（多用于嵌入到HTML中）

```php+HTML
<html>
    <head>
        
    </head>
    <body>
        <!--当前内容属于HTML内容-->
        
        <!--开始PHP代码书写：先写出PHP开始标记<?php-->
        <?php
    		这里的内容都属于PHP的，PHP引擎也只会解析这部分内容
    	?>
        <!--PHP代码书写结束，需要使用PHP结束标记?>-->
    </body>
</html>
    
```

2、没有结束标记的使用（多为独立的PHP文件）

```php
<?php	
    都是PHP代码（包括空行到结尾）
    PHP引擎会自动解析到最后
```



> 小结

1、PHP标记是为了让PHP引擎能够识别PHP代码

2、PHP标记分为起始和结束两个部分

* 起始标记：`<?php`，是PHP代码开始前必须先写好的
* 结束标记：`?>`，如果是独立PHP文件，不建议使用；如果是嵌入在HTML，最好使用



## 2、PHP注释



提问：写代码时，如何清晰的让自己或者团队知道代码有什么作用？

答案：注释



> 目标：掌握注释的实际运用



> 概念

**注释**：注释是一种使用代码符号之外的、通俗易懂的文字描述代码作用或者逻辑的符号。PHP引擎在解析时，会忽略注释标记及被注释的内容。



注释分为两种：

* 行注释：`#`或者`//`，标记**当前行**符号后面的内容
* 块注释：`/*...*/`，标记**起始和结束符号内**的所有内容



> 使用规则

1、行注释：当前注释描述的内容不多，或者不会超过一行

* 独占一行使用
* 在代码之后使用

2、块注释：当前注释描述的内容较多，通常会有多种信息或者内容较多超过一行

* 独占一行开始：`/*`
* 独占一行结束：`*/`



> 示例

```php
#1、这是一行独立的注释，下面的内容将输出hello world（建议）
echo 'hello world';	//2、简单内容也可以在代码后直接写（不建议）
	
/*
 3、从这开始全是注释
 @author 作者信息
 @date	 开发日期
*/
```



> 小结

1、注释是为了让**人**在看代码时能够容易看懂代码

2、注释分为两种基本类型

* 行注释：使用`#`或者`//`，用来注释简单描述
* 块注释：使用`/*...*/`，用来注释复杂描述

3、一个具有良好职业素养的程序员应该尽可能多的使用注释来描述自己的代码



## 3、语句结束符



提问：PHP写代码的时候，系统怎么能区分代码是一个部分还是一个整体呢？

回答：语句结束符



> 目标：掌握语句结束符在代码开发中的使用



> 概念

**语句结束符**：是一种必须的，显示的书写出来，用来告知PHP引擎，当前代码是一个整体的符号。在PHP中必须使用`;`（英文分号）来作为一行代码的语句结束符



> 示例

```php
#下面是一行独立代码（√）
echo 'hello world';		#echo 'hello world'是一个整体，而且结束了，所以必须使用；

#下面是一行错误独立代码（×）
echo 'hey girl'			#没有语句结束符;，系统会认为还没结束，会报错
```



> 小结

1、PHP语句结束符是用来表明一行代码已经书写完毕

2、PHP语句结束符使用`;`

3、PHP语句结束符必须存在，否则报错

4、养成一个写完代码就写语句结束符的习惯，让代码少小错误



## 4、总结



1、PHP基础知识包含三个内容

* PHP标记：让PHP引擎识别PHP代码
  * 起始标记（必写）：`<?php`
  * 结束标记（看情况）：`?>`
* PHP注释：用通俗的文字描述代码的作用
  * 行注释：注释一行信息，使用`#`或者`//`
  * 快注释：注释多行信息，使用`/*...*/`
  * 合格的程序员要养成良好的注释习惯
* 语句结束符：让PHP引擎知道一行代码已经写完
  * 使用方式：`;`（英文分号）

2、掌握了PHP语法规则，我们就可以开始真正学习PHP的内在知识



# 二、PHP基础知识



> 目标：掌握PHP基本的知识点，运用基础知识实现PHP代码的数据加工处理

* 变量：变量的作用和操作
* 常量：常量的作用和操作
* PHP数据类型：数据类型的概念和应用
* PHP运算符：运算符的作用和应用



## 1、变量



提问：编程语言一定会涉及到数据加工，那么数据在程序中是如何保存的呢？

答案：变量



> 目标：掌握PHP中变量的定义和使用



> 概念

**PHP变量**：是一种能够存储数据的符号

* 所有的变量都是以`$`符号开始
* 变量所保存的数据都可以随意改变
* 变量必须先定义才能使用，否则报错



> 步骤

1、需要定义变量

2、访问变量

3、修改变量

4、删除变量



> 示例

```PHP
#定义变量：将数据值10赋值给变量$num
$num = 10;

#访问变量：输出变量的值
echo $num;

#修改变量的值：将10换成hello world
$num = 'hello world';

#删除变量
unset($num);
```



> 变量规则

1、PHP变量以$符号开始

2、变量的名字由字母、下划线和数字构成，其中不能以数字开头

3、PHP中变量名是区分大小写的，所以\$a和​$A是两个变量

4、变量命名应该见名知意，如名字\$name，年龄​\$age

5、复杂变量名可以使用驼峰法（\$serverName）或者下划线法（$server_name），推荐下划线法



> 小结

1、PHP中变量以$符号开始

2、变量是用来保存一些可以变化的数据的：增查改删

3、变量需要先定义才能访问，否则报错：未定义的变量

4、变量的操作包含增查改删

5、PHP是一种弱类型语言，所以变量可以存储任何数据

6、变量名区分大小写

7、变量名字应该见名知意



## 2、预定义变量



提问：浏览器用户提交的数据我们怎么访问呢？

答案：预定义变量



> 目标：了解常见的预定义变量的含义，以后在运用的时候可以直接找到



> 概念

**预定义变量**：PHP系统内部定义的变量，也是PHP系统自动收集的数据结果

* 预定义变量也是变量，符合变量规则
* 预定义变量都是数组（数据组合，有多个数据在一起）
* 系统提供了9个预定义变量，每个变量都有自己特定的数据
  * $_GET：用户通过get方式提交的数据
  * $_POST：用户通过post方式提交的数据
  * $_REQUEST：用户通过get和post提交的数据
  * $_SERVER：用户和服务器的基本信息数据（数据的名字不由开发者控制，系统定义好）
  * $_FILES：用户提交的文件数据（文件上传）
  * $_SESSION：session数据
  * $_COOKIE：cookie数据 
  * $GLOBALS：所有全局变量，也是唯一一个不是以下划线开始的预定义变量
  * $_ENV：环境数据



> 步骤

1、明确需要的数据在哪个预定义变量中

2、使用预定义变量访问



> 示例

```php
#想要获取来访者的IP地址：在$_SERVER中，使用REMOTE_ADDR保存
echo $_SERVER['REMOTE_ADDR'];
```



> 小结

1、预定义变量是PHP系统保存的一些常用变量，方便开发者使用

2、预定义变量都是数组，需要以数组方式使用

3、预定义变量不需要特别记忆，但是对于常用的有所了解

- $_GET：get方式提交的数据（与表单和URL对应）
- $_POST：post方式提交的数据（与表单对应）
- $_SERVER：外部变量的获取，里面有很多，需要多了解一下



## 3、变量传值



提问：如何把一个变量的数据赋值给另外一个变量呢？

回答：变量传值



> 目标：掌握PHP中变量传值的应用和机制



> 概念

**变量传值**：是指有一个变量已经存在数据，然后将该变量赋值给另外一个变量

* 值传递：变量代表的数据传递，变量自身不受彼此影响
* 引用传递：变量代表的数据所在地址传递，一个改变会影响另外一个



> 步骤

1、定义变量并且赋值

2、变量传值

* 值传递：定义新变量，将存在的变量赋值给新变量
* 引用传递：定义新变量，将存在的变量所指向的内存地址（&）赋值给新变量



> 示例

```php
#值传递
$a = 10;
$b = $a;		#将$a的值10，取出后赋值给$b，所以$b的值也是10

#引用传递
$c = 10;
$d = &$c;		#将$c的值10的内存地址取出，赋值给$d，所以当前也都是10
```



**区别**

* 值传递在一个变量发生改变后，另外一个变量不受影响
* 引用传递在一个变量改变后，另外一个变量跟着改变

```php
#接上述代码
#值传递
$b = 100;
echo $a;		#10，$a和$b是值传递，一个改变，另外一个还是保留原来的值，不受影响

#引用传递
$d = 100;
echo $c;		#100，$c和$d是引用传递，一个改变，另外一个也跟着改变
```



> 小结

1、变量传值在开发中经常会碰到

2、变量传值有两种方式

* 值传递：变量的值赋值给另外一个变量，两个变量互不影响
* 引用传递：变量保存的值的地址传递一个另外一个变量，两个变量指向同一个值的内存地址，彼此影响



## 4、常量



提问：变量可以变化，如果有些数据不希望被乱改怎么办？

答案：常量



> 目标：掌握常量的概念以及PHP中常量的使用



> 概念

**常量**：一种存储数据的符号

* 常量通常大写字母
* 常量数据一旦定义，不可改变



> 步骤

1、定义常量

* 使用函数：define('常量名',常量值);
* 使用关键字：const 常量名 = 常量值;

2、访问常量

* 直接访问：常量名;
* 使用函数：constant('常量名');



> 示例

```PHP
#使用函数定义
define('VERSION',1.0);
#使用关键字定义
const PI = 3.14;

#直接访问
echo PI;
#使用函数访问
echo constant('VERSION');
```



> 常量规则

1、常量名字通常使用大写（允许小写，但是程序员默认都使用大写）

2、名字由字母、下划线和数字组成，不能以数字开头

3、常量名定义应该做到见名知意

4、复杂常量名通常使用下划线法

5、常量名字可以比较松散，但是不建议使用，如define('-_-','笑脸')是系统允许的（访问时就必须使用函数访问）



> 扩展

1、PHP7以后常量允许定义数组常量（一次性定义多个常量），访问时使用数组下标访问

```PHP
#定义数组常量
const MATH = array(
	'PI' => 3.14,
    'E'  => 2.72
);

#访问
echo MATH['PI'];
```



> 小结

1、常量是用来保留一些不希望改变的数据的

2、常量使用函数define或者关键字const定义，二者有些区别，在后面学习的时候会遇到

3、常量在定义后只能访问，不能修改和删除

4、PHP常量在PHP7以后允许值为数组



## 5、系统常量



提问：系统内部有没有像预定义变量那样的预定义常量呢？

回答：有，系统常量



> 目标：了解PHP中常见的系统常量，掌握常用几个的使用方法



> 概念

**系统常量**：系统内部定义的常量，用户可以直接访问，也只能访问

* 固定系统常量：值是固定的
* 魔术常量：值是可变的



> 常用系统常量

固定系统常量

* PHP_VERSION：PHP版本号
* PHP_INT_SIZE：PHP中整数所占用的字节数
* PHP_INT_MAX：PHP中整数能表示的最大数



魔术常量：以双下划线`__`开始，也以双下划线`__`结束

* \_\_DIR\_\_：当前运行文件的所在绝对路径（directory）
* \_\_FILE\_\_：当前运行文件的绝对路径（带文件名）
* \_\_LINE__：当前代码所在的行号
* _\_FUNCTION__：函数内部使用，表示当前函数的名字
* _\_CLASS__：类内部方法里使用，表示当前类的名字
* _\_METHOD__：类内部方法里使用，表示当前方法的名字（带类名）
* _\_NAMESPACE__：当前所属命名空间的名字



> 示例

```php
#固定常量
echo PHP_VERSION;	#7.2.4
echo PHP_INT_SIZE;	#4
echo PHP_INT_MAX;	#

#魔术常量
echo __DIR__;
echo __FILE__;
echo __LINE__;
```



> 小结

1、系统内部为我们定义了很多常量

* 固定常量：值是不变的
* 魔术常量：值是不确定的（性质确定）

2、魔术常量在开发时很有用



## 6、数据类型



提问：PHP变量赋值的时候有的地方有引号，有的不需要引号，为什么呢？

回答：数据类型



> 目标：了解PHP中数据分类的依据和对应的类型



> 概念

**数据类型**：数据类型在数据结构中的定义是一组**性质相同的值的集合**以及定义在这个值集合上的一组操作的总称。

* PHP变量没有数据类型：弱类型，可以存储任何数据
* 只有数据是进行分类的



PHP中数据类型分为三大类八小类

* 基本数据类型
  * 整形（int/integer)：整数数据
  * 浮点型(float)：小数数据和超过整形范围的整数数据
  * 布尔型(bool/boolean)：布尔类型数据，只有true和false两个值
  * 字符串型(string)：字符串数据（最常见）
* 复合数据类型
  * 数组型(array)：数组数据（即多个数据存放到一个变量中）
  * 对象型(object)：对象数据，由类实例化得到（面向对象）
* 特殊数据类型
  * 资源型(resource)：资源数据（数据库资源\文件资源）
  * 空型(null)：没有存储任何数据



> 示例

利用var_dump()可以查看变量的详细情况：数据大小（或长度），数据类型

```PHP
$a = 100;
$b = 'hello';
var_dump($a,$b);	#多个可以一起（var_dump通常在开发阶段用来检查结果的正确性）
#打印结果：
#int(100) 			#int类型，值为100
#string(5) "hello"	#string类型，长度为5个字节，值为hello
```



> 小结

1、数据分类是根据数据的性质的同一性进行分类

2、PHP中将数据分成8类

* 整型：整数
* 浮点型：小数和超出整数范围的整数
* 布尔型：是和否
* 字符串型：字符串数据
* 数组型：数组数据
* 对象型：对象数据
* 资源型：资源数据
* 空型：没有数据

3、可以使用var_dump来查看数据的具体类型和结果详情

4、对象型、资源型和空型需要学习到一些高级知识时会碰到，暂时不细讲



### 6.1、整型



> 目标：掌握整型数据的定义和输出方式



> 概念

**整型**：数据是整数，但是根据进制方式不同，有不同的数据格式

* 十进制：默认，逢十进一，有0-9共十个符号，阿拉伯数字即可，如123
* 八进制：逢八进一，有0-7共八个符号，起始使用0标志，如0123
* 十六进制：逢十六进一，有0-9、a-f共16个符号，起始使用0x标志，如0x123
* 二进制：逢二进一，有0-1共两个符号，起始使用0b标志，如0b101



> 示例

```php
#整型
$int1 = 123;	#默认十进制
$int2 = 0123;	#八进制表示
$int3 = 0x123;	#十六进制表示
$int4 = 0b101;	#二进制表示
```



虽然定义数据的时候可以使用多种进制表示，但是显示数据的时候，默认PHP都会转换成10进制输出

```php
#接上述代码
echo $int1,$int2,$int3,$int4;	#123,83,291,5
```



如果想要保持原来的进制输出，就需要使用printf(格式,数据1,数据2...)来实现

```PHP
#接上述代码
printf('%d',$int1);		#十进制输出$int1
printf('%o',$int2);		#八进制输出$int2
printf('十六进制是%x,二进制是%b',$int3,$int4);
```



注意：整数最大保存空间为PHP_INT_SIZE的值，即8个字节（PHP7以前是4个字节），能表示的最大值是PHP_INT_MAX的值，最小值是PHP_INT_MAX + 1的负数（PHP支持正负数）

```PHP
echo PHP_INT_SIZE;		# 4
echo PHP_INT_MAX;		# 9223372036854775807，最小值是 -9223372036854775808
```





> 小结

1、整型就是保存的是整数

2、整数的形式有多种，有不同的定义方式：

* 十进制：直接0-9定义
* 八进制：前面使用0，后跟0-7
* 十六进制：前面使用0x，后跟0-9+a-f
* 二进制：前面使用0b，后跟0-1

3、PHP不管定义时采用的是什么整型，输出都默认转换成十进制

4、想要保留原来格式，或者指定格式输出整数，使用printf()

* 十进制：%d
* 八进制：%o
* 十六进制：%x
* 二进制：%b

5、PHP中整型是有符号类型（有正负）

* 最大值：PHP_INT_MAX
* 最小值：-PHP_INT_MAX - 1



### 6.2、进制转换



> 目标：了解进制的原理，知道PHP中有进制转换的快捷函数



> 概念

**进制转换**：是指根据不同的进制要求，将原始数值（通常指整数）转换成目标进制。

* 二进制与十进制互转
* 二进制与八进制互转
* 二进制与十六进制互转
* 八进制与十进制互转
* 八进制与十六进制互转
* 十进制与十六进制互转



> 原理

任意进制转十进制的通用方法

![其他进制转十进制](图片\其他进制转十进制.gif)



二进制转八进制或者十六进制

* 二进制转八进制：从右边开始依次取三位转换成十进制，将所有结果合并即可（三位二进制最大7：111=>7）

`11111111` => `11,111,111` => `3,7,7` => 377

* 二进制转十六进制：从右边开始依次取四位转换成十进制，将所有结果合并即可（四位二进制最大15：1111=>15 == F）

`11111111` => `1111,1111` => `F,F` => FF

* 八进制转二进制：每位数转换成三位的二进制，将所有结果合并即可

`123` => `1,2,3` => `001,010,011` => 00101011 => 101011（左侧的0可以忽略）

* 十六进制转二进制：每位数转换成四位的二进制，将所有结果合并即可

`123` => `1,2,3` => `0001,0010,0011` => 000100100011 => 100100011



> 简化

在PHP中，已经考虑到业务的需求，所以PHP提供了一系列函数来实现各类进制转换，以十进制为基准

* bindec：二进制转十进制
* decbin：十进制转二进制
* decoct：十进制转八进制
* octdec：八进制转十进制
* dechex：十进制转十六进制
* hexdec：十六进制转十进制

```php
#示例：十六进制转十进制
hexdec('123');		#结果：291
```



> 小结

1、进制转换原理可以以10进制为基准互转

2、PHP提供了一套以十进制为基准的转换函数，利用十进制与其他进制组合成单词即可实现函数转换

* 八进制：oct
* 十进制：dec
* 十六进制：hex
* 二进制：bin



### 6.3、浮点型



> > 目标：掌握浮点型的概念和注意事项



> 概念

**浮点数**：即有小数点的数或者数值超过整型能表达的最大数

* 小数：1.2或者0.12
* 科学计数法产生的数：4E3 == 4 * 10 ^ 3
* 超过整型的数： PHP_INT_MAX + 1
* 浮点型存储空间：8个字节



浮点数是有有效位的

* **精度** ==> 精确度
* PHP7中的有效精度是13-14位，即数据如果有效数字超过该值，就会自动被四舍五入
  * 13位：肯定精准
  * 14位：如果只有14位数字，那么精准；如果超出14位，第十四位是四舍五入的结果
* PHP7中浮点数最大表示：1.8e308



> 示例

```PHP
#以下都是浮点数
$f1 = 1.2;
$f2 = 4e5;
$f3 = PHP_INT_MAX + 1;
```



> 浮点数存储原理简介

浮点数分为整数部分和小数部分，转换成二进制的方式有所不同，10.5举例

* 整数部分：十进制转二进制正常转即可，如10 => 1010
* 小数部分：小数乘以2，取整数部分，如 0.5 * 2 = 1.0，取1（如果还可以取，继续乘以2）

* 浮点数一共用8个字节存储，即64位，其中
  * 最左侧第一位是符号位：0表示正数，1表示负数
  * 从左侧开始第2位-54位存储数值
  * 剩余9位存储幂：即10的N次方，N最大为308



> 扩展

1、浮点数适合运用在精度要求不高的地方（如果确定精度不会超过14位，那么浮点数是精准的）

2、浮点数不适合进行运算后的精确比较（因为小数部分转换成二进制的时候是*2的出来的，取不尽就会丢失精度）

* `3`  与 `8.1 / 2.7` 比较，计算机是不会算出相等的结果的



> 小结

1、浮点数是用来表示小数、科学计数法数以及超过整数大小的整数的

2、浮点数是有精度范围的，PHP7中精度为14位有效数字

3、浮点数采用8个字节存储：存储原理为： `符号位` + `54位数值位` + `9位指数位`

4、浮点数的应用不建议在精度要求较高（超过14位）的地方使用

5、浮点数不适合进行精确比较（浮点数运算结果）



### 6.4、布尔类型



> 目标：了解布尔类型的值，掌握布尔类型的应用意义



提问：程序中如何表达==行==和==不行==呢？

回答：布尔值



> 概念

**布尔类型**：专门用来做判定结果的，只有两个值

* true：表示真（是）
* false：表示假（false）



> 示例

```PHP
#布尔表达式
$res = true;	
$res = FALSE;		#PHP中不区分布尔的大小写
```

**注意**：布尔值通常不会用来做结果保存，而是用来进行过程判定



> 小结

1、布尔类型只有两个值：true和false

2、布尔值不区分大小写：true和TRUE一样

3、布尔类型通常不是用来做存储数据，而是程序用来进行过程或者结果判定使用



### 6.5、字符串型



> 目标：掌握字符串的不同定义方式，以及各个方式的区别



> 概念

**字符串**：字符串是由数字、字母和下划线组成的一串字符



字符串是编程中用到最多的数据格式，有多种定义方式：

* 单引号包裹：使用英文单引号`''`包裹字符
* 双引号包裹：使用英文双引号`""`包裹字符
* 定界符包裹：使用PHP中的定界符`<<<标识符` +` 标识符`结尾形式包裹（多行字符串的一种形式）
  * heredoc结构：双引号的一种多行字符串形式
  * nowdoc结构：单引号的一种多行字符串形式



> 示例

```PHP
#单引号字符串
$str1 = 'hello world';
#双引号字符串
$str2 = "hello world";
#定界符：heredoc：注意EOT并非固定，自己取名即可（但不要与关键字同名）
$str3 = <<<EOT
	$str1
EOT;
#输出：hello world

#定界符：nowdoc
$str4 = <<<'EOT'
	$str1
EOT;
#输出：$str1
```



**区别**

1、单引号是最简单字符串

* 里面能解析少量转义符：单引号（\'），反斜杠（\\\\）

```PHP
#单引号解析
$a = 100;
$str = 'abcdefg\r\n\t\'\"\\$a';		#输出：abcdefg\r\n\t'\"\$a
#单引号被解析'，反斜杠被解析\，其他均不解析
```



2、双引号相对单引号功能较多

* 里面能解释较多转义符：\$符号（\\$），双引号（\"），反斜杠（\\\\），回车换行符（\r\n），tap符（\t）
* 里面如果有PHP变量，也可以被解析

```PHP
#双引号解析
$a = 100;
$str = "abcdefg\r\n\t\'\"\\$a";		#输出：abcdefg  \'"\100
#\r\n转换成换行空格，单引号不解析\'，双引号解析"，反斜杠解析\，$a被解析100
```

3、定界符中heredoc与双引号效果一致，nowdoc与单引号一致

* 定界符会自动保留格式：即如果内部字符串有换行之类的会自动保留



**注意**

1、双引号解析变量时，系统是有规矩匹配变量的

* 变量名不要与其他字母或者数字保留在一起：如"\$abc"系统会自动识别​\$abc，而不是​$a
  * 解决方案1：让变量与后面的内容之间有空格，如"\$a bc"系统识别​$a（此时会额外多出一个空格）
  * 解决方案2：使用{}将变量独立包裹，如"{\$a}bc"系统识别$a（建议）

2、使用定界符定义多行字符串时有很多规矩

* 定界符内的所有内容都是字符串的内容（包括注释）

* 定界符的起始符号之后不能有任何信息，包括空格
* 定界符的结束符号必须顶格
* 定界符的结束符号后同样不能有任何信息

```PHP
#错误示范1：定界符起始符号后有内容
$str = <<<EOT #这是起始
	hello world
EOT;

#错误示范2：定界符结束符号不顶格
$str = <<<EOT
	hello world
	EOT;

#错误示范3：定界符结束符号后有内容
$str = <<<EOT
	hello world
EOT;	#字符串结束
```



> 小结

1、字符串是程序编码中应用最多的一种类型，可以使用多种方式定义

* 单引号定义
* 双引号定义
* 定界符定义
  * heredoc定义：代替双引号
  * nowdoc定义：代替单引号

2、单引号与双引号有区别

* 单引号解析的转义符号较少：\'和\\\\
* 双引号解析的转义符号较多：\"、\\\\、\r\n、\t、\\$
* 双引号中可以解析变量，但要注意变量的规则
  * 让变量名与其他可能让系统误解的符号分开
  * 给变量名增加一个{}

3、使用定界符的时候要注意定界符的严格要求

* 起始符号后不能有任何内容（包括空格）
* 结束符号必须顶格
* 结束符号后不能有任何内容



### 6.6、数组类型



> 目标：掌握数组的定义、元素添加以及元素访问方式，了解数组所代表的作用



> 举例子

![数组概念](图片\数组概念.gif)

提问：一个PHP变量中能不能保存多个数据呢？

回答：可以，**数组**



> 概念

**数组**：多个元素的序列组合

* 数组由元素组成
* 元素由下标key和值Value组成（键值对 键 => 值）
  * 如果元素下标都是数字：索引数组
  * 如果元素下标都是字符串：关联数组
  * 如果下标有数字也有字符串：混合数组
* 数组元素的访问需要通过下标实现
* 数组通常用来保存一组相关的数据，而不是随意搭配



> 步骤

1、定义数组

* 空数组：值为array()或者[]
* 非空数组：['张三']（只显示的放了值，下标键是自动生成）
* 多元素数组：使用逗号分隔元素['张三','男',30]
* 指定下标数组：['name' => '张三','gender' => '男', 'age' => '30']

2、添加元素

* 使用保存数组的变量后加上[]，表示一个系统自动指定下标，然后等于某个值
* 使用保存数组的变量后加上[1]，表示指定下标为1（可以是字符串），然后等于某个值

3、访问元素

* 通过变量后加上[1]，必须指定元素下标，访问某个元素
* 如果直接使用变量，表示访问整个数组（不能echo输出）

4、修改元素

* 通过数组变量加上[1]，修改指定下标对应的元素，等于某个新值即可

5、删除元素

* 使用unset()，然后指定数组变量加上[1]，删除指定下标
* 使用unset()，指定变量删除整个数组



> 示例

```PHP
#定义数组：空数组
$arr1 = array();
$arr2 = [];

#定义非空数组
$arr3 = [1];				#单个元素
$arr4 = ['张三','男',30];	  #多个元素：没有指定下标，下标从0开始自然增长
$arr5 = ['name' => '张三'];  #指定下标，下标可以是数字也可以是字符串

#添加元素
$arr1[] = 10;				#添加一个元素值为10，下标系统自动给（第一个元素是0）
$arr2['gender'] = '女';		#添加一个元素下标为gender，值为女

#访问元素
echo $arr4[0];				#张三
echo $arr5['name'];			#张三

#修改元素
$arr5['name'] = '王五';		

#删除元素
unset($arr4[1]);			#删掉 男 这个元素
unset($arr4);				#删除整个数组
```



**注意**：

1、索引数组（纯数字下标）添加元素，默认以当前元素最大的下标开始自动加1

2、索引数组通常都不会刻意指定下标（从0开始自增长）

3、一般数组很少使用混合数组（要么下标全数字，要么下标全字符串）

4、PHP数组特点

* PHP数组中的元素没有数量限制，即数组不限定长度
* PHP中数组可以动态增加元素
* PHP中数组元素的值可以是任意数据类型
* PHP中数组下标可以是纯数字（索引数组）、纯字符串（关联数组）和混合数字和字符串（混合数组）



> 小结

1、数组是多个数据元素的集合保存

2、数组元素由下标和值组成，下标可以是数字或者字符串，值可以是任意数据类型

3、一个数组通常存储的是一组相关数据，如个人信息

4、数组的定义方式有多种

* 空数组：\$arr = array() / $arr = []
* 有元素：\$arr = [1] / ​$arr = ['name' => '习大大']

5、数组元素的访问、修改和删除，都是通过数组下标实现

6、PHP中数组根据下标组成可以分为多种

* 索引数组：所有元素下标全是数字
* 关联数组：所有元素下标全是字符串
* 混合数组：元素下标有数字的也有字符串的（基本不使用）



### 6.7、二维数组



> > 目标：了解二维数组的作用以及常见的数据存储形式



提问：一个数组是用来保存一类相关信息的，那么如果有很多个具有很多信息的数据该如何存储呢？

答案：二维数组



> 概念

**二维数组**：数组中的元素本身也是一个数组，我们就称之为二维数组

* 二维数组的元素都是一个一维数组
* 二维数组的第一维的下标通常是索引，第二维是关联



**多维数组**：PHP中理论上不限定数组的层级，当数组元素本身又是一个二维数组的时候，就是多维数组

* 数组维度超过二层即可为多维数组



> 步骤

1、定义一维数组，保存到变量

2、定义一个新数组，将原来的数组保存到新数组元素中

3、数组访问先通过一维下标找到对应的元素，然后通过二维下标找到更深的元素



> 示例

```PHP
#定义一维数组
$p1 = array('name' => '鸣人','skill' => '影分身');
$p2 = array('name' => '佐助','skill' => '千鸟');

#定义二维数组
$p = array($p1,$p2);		#$p1元素的下标为0，$p2的下标为1

#访问元素：通常是访问二维元素
#获取第一个元素的名字
echo $p[0]['name'];

#追加一个数组元素
$p[] = array('name' => '小樱','skill' => '治疗术');
```



> 小结

1、二维数组就是数组中的元素都是一维数组

2、多维数组在PHP中也允许出现，就是数组的层级大于3层，但是尽量不要超过3层（效率低）

3、二维数组的存储形式通常规则如下

* 一维数组元素下标为数字（索引数组：外层）
* 二维数组元素下标为字符串（关联数组：内层）

4、不管数组有多少层，所有的访问都是以下标一层一层寻找：$变量[一层下标]\[二层下标]\[...N层下标]



### 6.8、类型判定



> 目标：掌握类型判定的意义，了解类型判定的常用方法



提问：PHP在进行数据操作的时候，需要用到某些特定类型的数据，PHP如何知道呢？

回答：类型判定



> 概念

**类型判定**：即对存储数据的变量（本质是数据）进行类型确定



PHP提供了一套类型判定的函数，以供使用

* 函数不需要拼命记住，都是以`is_` + `数据类型` 组成
* 函数在操作手册中都有，输入`is_` 即可查到所有



> 常用类型判定

系统提供的类型判定很全，有几个特殊的需要了解一下

* is_numeric：判定数据是否是数值，如果是返回布尔TURE，否则返回FALSE
* is_scalar：是否是标量（基础类型）数据，如果是返回布尔TRUE，否则返回FALSE
* 类型代表：is_int，判定是否是整型数据，如果是返回布尔TRUE，否则返回FALSE



> 示例

```PHP
#定义变量
$num = 100;
$str = '100';

#判定
var_dump(is_int($num));			#TURE，100是整数
var_dump(is_int($str));			#FALSE，虽然值是100，但是用引号包裹的是字符串
var_dump(is_numeric($str);		#TRUE，is_numeric只要是数值都可以，包括数值型字符串
var_dump(is_scalar($num));		#TRUE，100是整型，是基础类型
var_dump(is_scalar($str));		#TRUE，'100'是字符串，是基础类型
```



> 小结

1、类型判定是因为某些特定情况下，需要保证数据格式能对上

* 不要相信任何外来数据：保证程序的安全和逻辑完整性

2、类型判定是用到PHP提供的系统函数，函数以`is_` + `数据类型`

* is_int：判定整型（is_integer）
* is_float：判定浮点型
* is_bool：判定布尔型（is_boolean）
* is_string：判定字符串型
* is_null：判定空型
* is_array：判定数组型
* is_resourse：判定资源型
* is_object：判定对象型

3、常见的数据类型判定，有两个额外的判定函数

* is_numeric：判定是否是数值或者数值型字符串
* is_scalar：判定是否是基础数据类型（整型、浮点型、布尔型、字符串型）



### 6.9、类型转换



> 目标：了解类型转换的原因，掌握类型转换的逻辑



提问：如果某项数据的类型如字符串100，而要参与计算的是数值运算，要怎么办？

回答：类型转换



> 概念

**类型转换**：即将某种不符合的类型转换成目标类型

* 自动转换：系统自动转成目标类型（方便）
* 强制转换：通过代码强制转换成目标类型（效率高）



> 步骤

1、自动转换

* 系统自动检测所需要类型
* 系统自动检测数据的类型
* 系统自动转换成目标类型（不改变数据本身）

2、强制转换

* 明确所需要类型
* 强制转换成所需类型
  * 不改变原来数据：在数据前使用`(目标类型)`，如(boolean)\$a，将变量$a的值取出来转成布尔结果
  * 改变原来数据：使用settype(变量,'目标类型')，如settype(\$a,'bool')，将变量​$a的值转成布尔结果
* 强制转换的类型：资源和NULL不能强制转换
  * integer：转换成整型
  * float：转换成浮点型
  * bool：转换成布尔类型
  * string：转换成字符串类型
  * array：转换成数组类型
  * object：转换成对象类型



> 示例

```php
#定义数据：假装是外来数据
$num1 = 5;
$num2 = '1.23a';

#算术运算：求和（自动转换）：只能是数值操作
echo $num1 + $num2;						#6.23
#系统判定当前是加法操作，需要数值类型（整型|浮点型）
#系统判定当前参与运算的数据类型：$num1是整型，$num2是字符串型
#系统自动转换不符合目标的类型编程目标类型：$num2 ==> 数值型（浮点型） ==> 1.23

var_dump($num2);					#string(5)，依然是字符串，值也是'1.23a'，没有改变

#算术运算：求和（强制转换）：只能是数值操作（不改变类型
echo (float)$num1 + (float)$num2;	#6.23

var_dump($num1,$num2);				#int 100, string(5) '1.23a'

#强制转换：改变类型（一般比较少用，除非是特定位置）
settype($num1,'float');
settype($num2,'float');

var_dump($num1,$num2);				#float 100,float 1.23
```



常见的转换逻辑

1、字符串转数值

* 纯数值字符串 =》相应数值：'123.1' => 123.1
* 数字开头但有字母 =》 保留数字部分：'12a' => 12
* 小数点开头 =》 保留第一个小数点及之后的连续数字：'.1.1.a' => 0.1
* 字母开头 =》 0：'a123' => 0

2、其他类型转布尔：极少转换后是FALSE，基本都是TRUE，以下除外

* 布尔FALSE转布尔：FALSE
* 整型0转布尔：FALSE
* 浮点型0.0转布尔：FALSE
* 空白字符串''和字符串'0'转布尔：FALSE
* 空数组array()转布尔：FALSE（比较多运用）
* 空类型NULL转布尔：FALSE



> 小结
>
> 1、类型转换是根据目标需求（运算）将数据变成目标格式
>
> * 自动转换（PHP用的最多）：系统自动识别
> * 强制转换（建议）：开发者限定
>   * 对值进行类型控制：在变量前使用：(目标类型)，不会改变变量本身
>   * 对变量进行类型重置：使用settype，会改变变量
>
> 2、类型转换逻辑
>
> * 字符串转数值
> * 其他类型转布尔
>   * 较多转都是布尔true
>   * 极少数转成false



## 7、运算



> 目标：了解PHP中运算符的分类



提问：PHP中拿到了各种数据之后，是用来干什么的？

回答：运算



> 概念

**运算符**：是PHP中的一些特殊符号，系统会自动根据这些特殊符号，将数据进行相应的运算



PHP中运算符有很多种：

* 赋值运算符：赋值操作
* 算术运算符：算术计算
* 错误抑制符：抑制报错
* 比较运算符：数据对比
* 合并运算符：真伪判定给出不同结果
* 逻辑运算符：逻辑结果判定
* 连接运算符：字符串连接
* 三目运算符：真伪判定给出不同结果
* 自操作运算符：简化操作



> 步骤

1、确定当前需要使用到的运算符号

2、根据运算符号的规则确定需要参与的表达式个数

3、将对应的表达式和符号按照正确的顺序排列好即可



> 示例

```PHP
#PHP变量赋值本质
#1、赋值符号为=
#2、赋值符号确定=左边为一个变量名，右边为一个产生结果的表达式
#3、排列

#给变量$a赋值一个常数10
$a = 10;
$b = 1 + 1;
```



> 小结

1、运算符是系统提供的一类特殊符号，能够让系统对数据进行相关加工操作

2、PHP中运算符种类繁多，我们可以根据实际的需要进行选择

- 赋值运算符：赋值操作
- 算术运算符：算术计算
- 错误抑制符：抑制报错
- 比较运算符：数据对比
- 合并运算符：真伪判定给出不同结果
- 逻辑运算符：逻辑结果判定
- 连接运算符：字符串连接
- 三目运算符：真伪判定给出不同结果
- 自操作运算符：简化操作
- 位运算符：根据计算机最小单位 `bit位` 进行运算（不多讲）

3、运算符的运算规则

* 确定要使用到的运算符（做什么运算）
* 确定运算符需要的表达式数量和性质
* 按照顺序将表达式和运算符排列好



### 7.1、赋值运算



> 目标：了解赋值运算符的作用，以及常用的几种赋值运算



> 概念

**赋值运算**：将运算符右边的结果赋值给左边的符号，通过访问左边的符号即可得到右侧的结果

* PHP中使用 `=` 进行赋值
* 赋值运算要求左边是能够存储数据的符号（变量、常量），右边是一个有结果的表达式（值、有结果的计算过程）



PHP中赋值运算符有以下几种：

* =：普通赋值
* +=|-=|*=|/=|%=：先将左边的符号与右边的表达式进行相应的操作（%是取余），然后赋值给左边
* .=：先将左边的符号的结果与右边的结果进行字符串连接（.是字符串连接符），然后赋值给左边



> 示例

```PHP
#普通赋值
$a = 10;
$b = 20;
$c = 'string';

#复合赋值
$a += 10;		#表示$a = $a + 10; 先将$a + 10，然后将结果赋值给$a
$c .= 'hello';	#表示$c = $c . 'hello'
```



注意

* 复合赋值运算是将左侧与右侧的整体结果进行运算

```PHP
$a = 10;
$a -= 100 - 90;

#以上右侧的结果是100 - 90 = 10，所以整体结果应该是$a = $a - (100 - 90) = 10
#错误理解： $a = $a - 100 - 90 = -180
```

* 当复合赋值是/=或者%=的时候，右侧的结果不能为0

```PHP
$a = 10;
$a /= 0;		#错误：等价于$a = $a / 0 = 10 / 0 = 无限大
```



> 小结

1、赋值运算的基本符号是 `=`，也是程序语言中最基本的运算符

2、赋值运算分为两类

* 基本赋值：`=`，右侧结果赋值给左侧存储数据的符号
* 复合赋值：`+=|-=|*=|/=|%=|.=`，先将左侧数据符号代表的数据与右侧==结果==进行相应运算后赋值给左侧符号

3、复合赋值运算时要注意 `/=` 和 `%=` 运算时，右侧结果不能为0



### 7.2、算术运算



> 目标：了解算术运算符的作用，并掌握算术运算的运算规则



> 概念

**算术运算**：实现两个数据的算术运算

- 普通算术运算，需要符号左右两边都是数值
- +：加法运算，左右两边相加
- -：减分运算，左边减去右边
- *：乘法运算，左边乘以右边
- /：除法运算，左边除以右边（右边不能为0）
- %：取余运算（模运算），左边除以右边，保留整数部分结果（右边不能为0）
- **：幂运算，PHP7后新增，底数的指数次相乘
- *、/、%的优先级比+、-的要高
- 相同优先级的情况下，从左往右开始运算



> 示例

```PHP
#算术运算
$a = 10;
$b = 8;

#加减乘除取余基本运算
$c = $a + $b;        #$c = 10 + 8 = 18
$d = $a / $b;        #$d = 10 / 8 = 1.25
$e = $a % $b;        #$e = 10 % 8 = 1（1.25取整数部分）

#幂运算
$f = $a ** 2;		 #$f = 10 * 10 = 100

#运算符优先级
$g = 10 + 10 / 10;	 #$g = 10 + 1 = 11
```

注意

* 除法运算 `/` 和取余运算 `%` 的右侧都不能为0
* 如果有多个表达式参与复合运算，那么可以使用 `()` 来提升优先级

```php
$f = (10 + 10) / 10;	#$f = 20 / 10 = 2
```





> 小结

1、算术运算是进行数学的算术操作

2、算术运算包含+、-、*、/、%、**六种操作

3、运算符有优先级

* *、/、%优先级比+、-要高
* 相同级别的优先级，从左往右开始运算
* 可以使用 `()` 来提升优先级



### 7.3、错误抑制



> 目标：了解错误抑制符的作用，灵活运用错误抑制符来实现可能出现的错误的抑制



提问：当进行算术运算的时候如果除数为0就错了，该怎么控制呢？

回答：数据判断或者暴力错误抑制



> 概念

**错误抑制**：在可能出现的错误的代码前使用错误抑制符，让错误不会报出来

* 错误抑制只需要在可能出现的错误的表达式之前使用即可
* 错误抑制符只有一个：`@`
* 错误抑制符只针对就近的目标，如果是针对结果，需要使用`()`（优先级考虑）
* 错误抑制符只能抑制简单错误（notice、warning）



> 示例

```PHP
#正常处理
$r = 10 / 0;		#报错：除数为0

#错误抑制处理
$r = @10 / 0;		#报错：出错的位置是 10 / 0 这个过程 ，抑制的位置是10，无意义

#正确处理
$r = @(10 / 0);		#不报错：因为是过程出错
```



> 小结

1、错误抑制符是用来抑制可能出现的错误的

* 抑制级别：notice、warning低级别错误

2、错误抑制符`@`应该用在出现错误的位置

* 如果只是一个表达式错误：那么直接`@`
* 如果错误是一个过程：那么需要先将过程使用`()`包起来，然后进行抑制



### 7.4、比较运算



> 目标：了解比较运算的意义和工作原理，掌握常用比较运算符的使用



提问：如何知道两个数据的大小呢？

回答：比较运算



> 概念

**比较运算**：比较两个数据的大小或者长度，然后得出比较结果

- 用于两个表达式的比较，比较的结果通常是true或者false
- \> ：左边大于右边返回true，否则返回false
- <：左边小于右边返回true，否则返回false
- \>=：左边大于或者等于右边返回true，否则返回false
- <=：左边小于或者等于右边返回true，否则返回false
- <=>：左边大于右边返回1，等于右边返回0，小于右边返回-1
- ==：左边等于右边返回true，否则返回false
- !=：左边不等于右边返回true，相等返回false
- ===：左边等于右边，且两边数据类型一致返回true，否则返回false
- !==：左边不全等于右边返回true，否则返回false



> 示例

```PHP
#定义数据
$a = 10;                  #数字10
$b = 5;
$c = '10';                #字符串10

#基本比较运算
$res = $a > $b;
var_dump($res);           #布尔true：10 > 5，成立

#全等运算
$res = ($a == $c);
var_dump($res);           #布尔true：10 与 '10'系统自动会转换成相同的格式比较，都是10，所以相等

$res = ($a === $c);
var_dump($res);            #布尔false：10与10值相同，但是10是数字，'10'是字符串，类型不同

#飞船运算
var_dump($a <=> $c);	   #0：相等，10与10值相同，类型不同不影响
```



注意：在PHP中比较运算比较特殊，通常系统会自动将类型转换成相同的然后进行比较，所以大家在使用\=\=和\=\=\=比较的时候，如果自己不够明确可以参照PHP操作手册中的类型比较表：PHP操作手册->附录->PHP类型比较表。    

![类型比较](图片\类型比较.jpg)



> 小结

1、比较运算就是比较两个数据的区别

2、飞船运算包含了大于、等于和小于三种运算

3、比较运算的结果普遍是true和false，飞船运算符的结果除外

4、比较运算通常在实际开发中用于判定数据的有效性

* 数值有大小可比较
* 字符串：比较对应的ASCII值
  * 大小写比较ASCII值
  * 如果是相同字符串，谁第一个不同的大谁赢

5、PHP在进行比较时，会自动将不同类型转换成同一类型进行比较，所以这块需要特别注意

* 松散比较 `==` ：只比较值即可
* 严格比较 `===` ：值和类型都比较



### 7.5、合并运算



> 目标：掌握合并运算的操作，以及合并运算符的实际运用



提问：用户提交数据时，我们怎么确定用户提交了数据呢？

回答：判定或者合并运算



> 概念

**合并运算**：合并运算是用于简单的数据存在性判定，不存在的时候给出一个设定值

* 合并运算需要一个判定：目标
* 合并运算需要一个设定值：目标不存在的时候的值
* 合并运算符： $a `??` B
  * \$a存在，整个表达式返回$a的值
  * $a不存在，整个表达式返回B值 
* 合并运算是保证代码的逻辑完整性：即总是有一个结果（不会不存在）



> 示例

```PHP
#假设用户是通过POST方式提交数据
$gender = $_POST['gender'];

#上述代码如果用户没有提交gender，那么会报错，我们可以通过合并运算符给定目标值
$gender = $_POST['gender'] ?? '男';	#用户提交了取$_POST的值，没有提交取gender
```



> 小结

1、合并运算符是 `??`

2、合并运算符是针对数据存在的判定

* 存在结果：取原始结果
* 不存在结果：使用替代结果

3、合并运算在进行一些数据获取时，如果数据不是那么重要的情况下使用（如果数据非常重要，那么就必须让用户提交，而不是给默认值）



### 7.6、连接运算



> 目标：了解连接运算的实际应用



> 概念

**连接运算**：专门为字符串连接操作设定的运算符

* 连接运算需要两个数据的参与
* 连接运算符只有一个： `.` 英文点
* 连接运算是将两个字符串连接成一个字符串
  * 如果数据本身不是字符串，系统会自动转变成字符串



> 示例

```php
$a = 'hello ';
$b = 'world';

echo $a . $b;		#将$a和$b连接起来，然后一次性输出：hello world
```



注意：在进行连接运算时，如果有其他运算，最好将其他运算使用 `()` 包起来（提升优先级）

```php
# +、-和.优先级一样，所以是先左后右
echo 'hello' . 5 + 5;			#5，同时报错：先算的hello . 5，编程hello5，然后去+5

#正确处理
echo 'hello' . (5 + 5);			#hello10，不出错
```



> 小结

1、连接运算是针对字符串连接使用的

2、连接运算符使用 `.` 实现

3、连接运算会将符号两边的数据先转换成字符串后运算

4、连接运算与其他运算符一起使用时，要主要运算符的优先级带来的问题



### 7.7、三目运算



> 目标：了解三目运算的逻辑，掌握三目运算符的应用



> 概念

**三目运算**：即有三个表达式参与运算的运算，是一种简单的判定以及给出结果的运算

* 三目运算：需要三个表达式参与运算
* 三目运算： 表达式1 ? 表达式2 : 表达式3
  * 如果表达式1为真：返回表达式2的结果
  * 如果表达式1为假：返回表达式3的结果
* 三目运算简化：表达式1 ?: 表达式3
  * 如果表达式1为真：返回表达式1的结果（等价于： 表达式1 ? 表达式1 : 表达式3）
  * 如果表达式1为假：返回表达式3的结果



> 示例

```PHP
#年龄大于等于18岁，可以上网，否则不能上网
$age = 15;

$res = $age >= 18 ? '上网' : '不能上网';
echo $res;		#上网：因为$age >= 18结果为真

#用户提交数据：如果有就用，没有就给初始值
$res = $_GET['age'] ?: 18;			#等价于合并运算：$res = $_GET['age'] ?? 18
```



三目运算是可以多个嵌入到一起的（不建议），如果有这种情况要特别注意，最好使用`()` 将子三目运算包起来

```PHp
#年龄小于18岁，未成年，大于18岁，小于30岁，青年，大于30，小于65，中年，大于65，老年
$age = 19;

#错误示例：自己看不懂，程序也看不懂
$res = $age >= 18 ? $age > 30 ? $age > 65 ? '老年' : '中年' : '青年' : '未成年';

#调整，每个子三目运算都进行包裹
$res = $age >= 18 ? ($age > 30 ? ($age > 65 ? '老年' : '中年') : '青年') : '未成年';

```



> 小结

1、三目运算标准需要三个表达式参与运算：表达式1 ? 表达式2 : 表达式3

* 表达式1成立：得到表达式2的结果
* 表达式1不成立：得到表达式3的结果

2、简化的三目运算与合并运算一样（合并运算在PHP7以后有的，就是为了简化三目运算）

* 表达式1 ? : 表达式3 ==== 表达式1 ?? 表达式3（不完全等价：三目运算是判定表达式1的结果是否为真，而合并运算是判定表达式1是否存在）

3、三目运算理论上可以无限嵌套，但是要注意对子三目运算的包裹（不建议使用）



### 7.8、逻辑运算



> 目标：了解逻辑运算的概念，掌握逻辑运算符的原理及应用



> 概念

**逻辑运算**：是针普通运算的结果的二次运算

* 逻辑运算一般需要1个或者2个表达式参与
* `&&`：逻辑与运算（也作and），左右两边结果都为true返回true，否则返回false
* `||`：逻辑或运算（也作or），左右两边结果至少有一个true返回true，否则返回false
* `!`：逻辑非运算，原来结果为true返回false，原来结果为false返回true

* 逻辑运算（逻辑与和逻辑或）也称之为短路运算：即左边表达式如果已经能够确定结果，那么右边表达式就不再判定
  * 逻辑或：如果左边第一个表达式已经为真，第二个表达式就不会运算（结果为真）
  * 逻辑与：如果左边第一个表达式已经为假，第二个表达式就不会运算（结果为假）
* 运算原理：将所有表达式的结果转换成布尔结果之后再进行运算



> 示例

```PHP
#简单示例
$a = true;
$b = false;

#逻辑运算
var_dump($a || $b);			#true，因为$a为true，所以整个结果为true
var_dump($a && $b);			#false，因为$b为false，所以整个结果为false
var_dump(!$a);				#false，因为$a为true，取反得到false

#通常参与逻辑运算的同时会有其他运算参与
$age = $_POST['age'];

$res = $age < 18 || $age > 65;		
#先执行左侧的$age < 18比较运算
#后执行右侧的$age > 65比较运算
#两个比较结果进行 || 逻辑运算

#短路验证
$a = 100;
$a == 100 || $b = 10;	#案例：实际开发不要出现运算中赋值

/*
 1、比较左边：$a == 100，结果为true
 2、发现是逻辑或运算：结果已经出来：true
 3、忽略$b = 10运算
*/
var_dump($b);			#未定义的变量
```



> 小结

1、逻辑运算符有三种： `&&` 逻辑与、`|| `逻辑或、`!`逻辑非 

* `&&` ：两个表达式都为真结果才为真，其他为假

* `||` ：两个表达式都为假结果才为假，其他为真

* `!` ：一个表达式，对本身布尔结果取反

2、 逻辑运算是对布尔结果进行比较

* 本身就是布尔结果：直接运算
* 本身非布尔结果：自动转换成布尔结果后再运算

3、逻辑运算通常与其他运算结合在一起运算

4、逻辑与和逻辑或也称之为短路运算

* 逻辑与：第一个为假，第二个不运算（短路）
* 逻辑或：第一个为真，第二个不运算（短路）
* 在实际开发中，应该将大概率能判定整个结果的运算放前面

5、逻辑运算在实际开发的时候运用比较多，尤其是逻辑复杂的程序



### 7.9、自操作运算



> 目标：了解自操作运算的原理，掌握自操作运算的应用



> 概念

**自操作运**：针对一个变量的自我操作运算，能够让变量实现自我按规矩改变

* 自操作运算只需要一个变量即可完成
* 自操作运算分为两种
  * ++：变量自增，即自己加1，然后赋值给自己
  * --：变量自减，即自己减1，然后赋值给自己
* 自操作符号分前置和后置：前后置的区别运用是在参与其他运算时体现
  * 前置自操作符：先运算自己、改变自己，然后把改变后的结果去参与其他运算
  * 后置自操作符：先把自己当前的值保留去参与其他运算，然后运算自己、改变自己
* 自操作在变量都是变化1的时候，而且需要重复执行时用到
  * 年龄：每年自增1
  * 寿命：每年自减1



> 示例

简单自操作运算

```php
#变量赋值：多个同时赋值
$a = $b = 10;	

$a++;		#等价于： $a = $a + 1
echo $a;	#11

++$b;		#等价于： $b = $b + 1
echo $b;	#11
#独立运算，前置与后置没有区别
```



前后置区别（虚岁生日和实岁生日）：参与其他运算

```PHP
$a = $b = 0;		#刚出生

#虚岁生日
echo '我今年：',++$a,'岁';	#我今年1岁：前置先改变自己，后参与运算

#实岁生日
echo '我今年：',$b++,'岁';	#我今年0岁：后置先参与运算，后改变自己

#最终$a和$b都变成了1
```



> 小结

1、自操作包含 `++` 和 `--` 都是一个变量参与的改变运算，每次都改变1

2、自操作运算包含前置运算和后置运算

* 前置自操作：先改变自己、后参与运算
* 后置自操作：先参与运算、后改变自己
* 条件：前后置的区别需要运算本身还要参与到其他运算
  * 输出
  * 算术运算
  * 连接运算

3、自操作运算是有规律的自增1或者自减1，实际在循环时会经常用到（循环条件的变更）



### 7.10、运算符优先级



> 目标：了解运算符的优先级，懂得使用`()`来提升复杂运算的优先级别



> 概念

**运算符优先级**：多种运算符结合一起运算时，系统会根据不同的优先级进行优先运算，从而导致运算结果不可预知

![运算符优先级](图片\运算符优先级.jpg)

图中，从上到下依次优先级降低（部分运算符没讲，略过）



> 示例

在不确定表达式中优先级顺序的时候，使用`()`来保证对应的运算不会被其他优先级高的所拆分

```PHP
$a = 10 + 5 * 2 / 10 % 3;	#11，因后续运算符都比+号高
$a = (10 + 5) * 2 / 10 % 3;	#0
```



> 小结

1、运算符优先级是系统提供的一种结合模式，优先级高的先结合，级别低的后结合

2、为了保障目标运算不被其他优先级高的影响，可以通过`()`来实现包裹